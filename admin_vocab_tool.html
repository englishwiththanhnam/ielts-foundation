<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>C√¥ng c·ª• Qu·∫£n tr·ªã T·ª´ v·ª±ng</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style> body { font-family: 'Be Vietnam Pro', sans-serif; } </style>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-4xl mx-auto bg-white p-8 rounded-2xl shadow-lg">
        <h1 class="text-3xl font-bold text-indigo-600 mb-2">C√¥ng c·ª• Qu·∫£n tr·ªã T·ª´ v·ª±ng</h1>
        <p class="text-gray-600 mb-8">T·∫°o v√† t·∫£i c√°c b·ªô t·ª´ v·ª±ng l√™n h·ªá th·ªëng m·ªôt c√°ch d·ªÖ d√†ng.</p>

        <div class="space-y-6">
            <div>
                <label for="firebaseConfig" class="block text-sm font-medium text-gray-700 mb-1">1. D√°n Firebase Config:</label>
                <textarea id="firebaseConfig" rows="5" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="const firebaseConfig = {...};"></textarea>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="vocabSetId" class="block text-sm font-medium text-gray-700 mb-1">2. ID c·ªßa B·ªô t·ª´ v·ª±ng (duy nh·∫•t):</label>
                    <input type="text" id="vocabSetId" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="V√≠ d·ª•: unit-1-family">
                </div>
                <div>
                    <label for="vocabSetTitle" class="block text-sm font-medium text-gray-700 mb-1">3. Ti√™u ƒë·ªÅ c·ªßa B·ªô t·ª´ v·ª±ng:</label>
                    <input type="text" id="vocabSetTitle" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="V√≠ d·ª•: Unit 1: Family">
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="vocabCsv" class="block text-sm font-medium text-gray-700 mb-1">4. D√°n n·ªôi dung file `vocab.csv`:</label>
                    <textarea id="vocabCsv" rows="10" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="Word,Type,Pronunciation,Meaning..."></textarea>
                </div>
                <div>
                    <label for="structureCsv" class="block text-sm font-medium text-gray-700 mb-1">5. D√°n n·ªôi dung file `structure.csv`:</label>
                    <textarea id="structureCsv" rows="10" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="C·∫•u tr√∫c / Idiom / C·ª•m t·ª´,√ù nghƒ©a..."></textarea>
                </div>
            </div>

            <button id="process-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-all">
                X·ª≠ l√Ω v√† T·∫£i l√™n Firebase
            </button>

            <div id="status" class="mt-4 p-4 bg-gray-50 rounded-md border border-gray-200 text-sm">
                Tr·∫°ng th√°i: S·∫µn s√†ng.
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script>
        let db;

        function initializeFirebase() {
            if (db) return true;
            const configText = document.getElementById('firebaseConfig').value;
            if (!configText) { alert("Vui l√≤ng d√°n Firebase Config!"); return false; }
            try {
                const firebaseConfig = new Function(`${configText} return firebaseConfig;`)();
                if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); }
                db = firebase.firestore();
                document.getElementById('status').innerText = 'Tr·∫°ng th√°i: ƒê√£ k·∫øt n·ªëi Firebase. S·∫µn s√†ng.';
                return true;
            } catch (error) {
                alert("L·ªói c√∫ ph√°p trong Firebase Config."); console.error(error); return false;
            }
        }

        // [FIX] H√†m parseCsv ƒë∆∞·ª£c vi·∫øt l·∫°i ho√†n to√†n ƒë·ªÉ x·ª≠ l√Ω d·∫•u ph·∫©y trong d·ªØ li·ªáu
        function parseCsv(csvText) {
            const lines = csvText.trim().split(/\r\n|\n/); // H·ªó tr·ª£ c·∫£ Windows v√† Unix line endings
            if (lines.length < 2) return [];

            const headerLine = lines.shift();
            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p header c√≥ d·∫•u ngo·∫∑c k√©p
            const headers = headerLine.split(',').map(h => h.trim().toLowerCase().replace(/"/g, ''));
            
            const rows = lines.map(line => {
                const row = {};
                // Regex to split by comma but ignore commas inside double quotes
                const values = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
                
                headers.forEach((header, index) => {
                    let value = (values[index] || '').trim();
                    // B·ªè d·∫•u ngo·∫∑c k√©p n·∫øu c√≥ ·ªü ƒë·∫ßu v√† cu·ªëi
                    if (value.startsWith('"') && value.endsWith('"')) {
                        value = value.substring(1, value.length - 1);
                    }
                    // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p "" b√™n trong (d·∫•u ngo·∫∑c k√©p escape)
                    row[header] = value.replace(/""/g, '"'); 
                });
                return row;
            });

            return rows;
        }


        function processDataSmart(vocabData, structureData) {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML += "<br>üß† B·∫Øt ƒë·∫ßu li√™n k·∫øt c·∫•u tr√∫c th√¥ng minh...";

            const vocabWords = vocabData.map(v => v.word);
            let structuresWithRootWord = [];

            structureData.forEach(struct => {
                const structureText = struct['c·∫•u tr√∫c / idiom / c·ª•m t·ª´'];
                if (!structureText) return;

                let found = false;
                for (const word of vocabWords) {
                    if (!word) continue;
                    // Regex ƒë·ªÉ t√¨m t·ª´ g·ªëc m·ªôt c√°ch ch√≠nh x√°c
                    const regex = new RegExp(`\\b${word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i');
                    if (regex.test(structureText)) {
                        structuresWithRootWord.push({ ...struct, word: word });
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    statusEl.innerHTML += `<br>‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y t·ª´ g·ªëc cho c·∫•u tr√∫c: '${structureText}'`;
                }
            });

            const structureGroups = structuresWithRootWord.reduce((acc, current) => {
                const key = current.word;
                if (!acc[key]) {
                    acc[key] = [];
                }
                acc[key].push(`${current['c·∫•u tr√∫c / idiom / c·ª•m t·ª´']}: ${current['√Ω nghƒ©a']}`);
                return acc;
            }, {});

            const finalVocabList = vocabData.map((vocabItem, index) => {
                const combinedStructure = structureGroups[vocabItem.word] ? structureGroups[vocabItem.word].join('; ') : '';
                return {
                    id: index + 1,
                    word: vocabItem.word || '',
                    type: vocabItem.type || '',
                    pronunciation: vocabItem.pronunciation || '',
                    meaning: vocabItem.meaning || '',
                    structure: combinedStructure
                };
            });
            
            statusEl.innerHTML += `<br>‚úÖ X·ª≠ l√Ω th√†nh c√¥ng ${finalVocabList.length} t·ª´ v·ª±ng.`;
            return finalVocabList;
        }

        document.getElementById('process-btn').addEventListener('click', async () => {
            if (!initializeFirebase()) return;

            const vocabSetId = document.getElementById('vocabSetId').value;
            const vocabSetTitle = document.getElementById('vocabSetTitle').value;
            const vocabCsv = document.getElementById('vocabCsv').value;
            const structureCsv = document.getElementById('structureCsv').value;
            const statusEl = document.getElementById('status');

            if (!vocabSetId || !vocabSetTitle || !vocabCsv || !structureCsv) {
                alert("Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß t·∫•t c·∫£ c√°c tr∆∞·ªùng.");
                return;
            }

            try {
                statusEl.textContent = 'B·∫Øt ƒë·∫ßu x·ª≠ l√Ω d·ªØ li·ªáu...';
                const vocabData = parseCsv(vocabCsv);
                const structureData = parseCsv(structureCsv);
                
                if (vocabData.length === 0) {
                    throw new Error("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ `vocab.csv`. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë·ªãnh d·∫°ng.");
                }

                const processedWords = processDataSmart(vocabData, structureData);
                
                const finalDataObject = {
                    title: vocabSetTitle,
                    words: processedWords
                };

                statusEl.innerHTML += `<br>ƒêang t·∫£i b·ªô t·ª´ v·ª±ng '${vocabSetId}' l√™n Firestore...`;
                
                await db.collection("vocab_sets").doc(vocabSetId).set(finalDataObject);

                statusEl.innerHTML += `<br>üéâ **TH√ÄNH C√îNG!** ƒê√£ t·∫£i b·ªô t·ª´ v·ª±ng l√™n Firestore.`;
                alert('T·∫£i l√™n th√†nh c√¥ng!');

            } catch (error) {
                statusEl.textContent = `L·ªói: ${error.message}`;
                console.error(error);
            }
        });
    </script>
</body>
</html>
