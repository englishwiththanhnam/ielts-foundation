<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>C√¥ng c·ª• Qu·∫£n tr·ªã T·ª´ v·ª±ng (v3.0 - Ch·∫Øc ch·∫Øn th√†nh c√¥ng)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style> 
        body { font-family: 'Be Vietnam Pro', sans-serif; } 
        textarea { resize: vertical; }
    </style>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-6xl mx-auto bg-white p-8 rounded-2xl shadow-lg">
        <h1 class="text-3xl font-bold text-indigo-600 mb-2">C√¥ng c·ª• Qu·∫£n tr·ªã T·ª´ v·ª±ng v3.0</h1>
        <p class="text-gray-600 mb-8">Ph∆∞∆°ng ph√°p nh·∫≠p li·ªáu m·ªõi: D√°n t·ª´ng c·ªôt ƒë·ªÉ ƒë·∫£m b·∫£o ch√≠nh x√°c 100%.</p>

        <div class="space-y-6">
            <div>
                <label for="firebaseConfig" class="block text-sm font-medium text-gray-700 mb-1">1. D√°n Firebase Config:</label>
                <textarea id="firebaseConfig" rows="4" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="const firebaseConfig = {...};"></textarea>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="vocabSetId" class="block text-sm font-medium text-gray-700 mb-1">2. ID c·ªßa B·ªô t·ª´ v·ª±ng (duy nh·∫•t):</label>
                    <input type="text" id="vocabSetId" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="V√≠ d·ª•: unit-1-family">
                </div>
                <div>
                    <label for="vocabSetTitle" class="block text-sm font-medium text-gray-700 mb-1">3. Ti√™u ƒë·ªÅ c·ªßa B·ªô t·ª´ v·ª±ng:</label>
                    <input type="text" id="vocabSetTitle" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="V√≠ d·ª•: Unit 1: Family">
                </div>
            </div>

            <!-- [THAY ƒê·ªîI L·ªöN] Giao di·ªán nh·∫≠p li·ªáu m·ªõi -->
            <div class="border-t pt-6">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">4. D√°n d·ªØ li·ªáu T·ª´ v·ª±ng (T·ª´ng c·ªôt m·ªôt)</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                    <div>
                        <label for="col-word" class="block text-sm font-medium text-gray-700 mb-1">C·ªôt 'Word'</label>
                        <textarea id="col-word" rows="12" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></textarea>
                    </div>
                    <div>
                        <label for="col-type" class="block text-sm font-medium text-gray-700 mb-1">C·ªôt 'Type'</label>
                        <textarea id="col-type" rows="12" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></textarea>
                    </div>
                    <div>
                        <label for="col-pronunciation" class="block text-sm font-medium text-gray-700 mb-1">C·ªôt 'Pronunciation'</label>
                        <textarea id="col-pronunciation" rows="12" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></textarea>
                    </div>
                    <div>
                        <label for="col-meaning-vocab" class="block text-sm font-medium text-gray-700 mb-1">C·ªôt 'Meaning'</label>
                        <textarea id="col-meaning-vocab" rows="12" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></textarea>
                    </div>
                </div>
            </div>

            <div class="border-t pt-6">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">5. D√°n d·ªØ li·ªáu C·∫•u tr√∫c (T·ª´ng c·ªôt m·ªôt)</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="col-structure" class="block text-sm font-medium text-gray-700 mb-1">C·ªôt 'C·∫•u tr√∫c / Idiom / C·ª•m t·ª´'</label>
                        <textarea id="col-structure" rows="10" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></textarea>
                    </div>
                    <div>
                        <label for="col-meaning-structure" class="block text-sm font-medium text-gray-700 mb-1">C·ªôt '√ù nghƒ©a'</label>
                        <textarea id="col-meaning-structure" rows="10" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></textarea>
                    </div>
                </div>
            </div>

            <button id="process-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-all">
                X·ª≠ l√Ω v√† T·∫£i l√™n Firebase
            </button>

            <div id="status" class="mt-4 p-4 bg-gray-50 rounded-md border border-gray-200 text-sm">
                Tr·∫°ng th√°i: S·∫µn s√†ng.
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script>
        let db;

        function initializeFirebase() {
            if (db) return true;
            const configText = document.getElementById('firebaseConfig').value;
            if (!configText) { alert("Vui l√≤ng d√°n Firebase Config!"); return false; }
            try {
                const firebaseConfig = new Function(`${configText} return firebaseConfig;`)();
                if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); }
                db = firebase.firestore();
                document.getElementById('status').innerText = 'Tr·∫°ng th√°i: ƒê√£ k·∫øt n·ªëi Firebase. S·∫µn s√†ng.';
                return true;
            } catch (error) {
                alert("L·ªói c√∫ ph√°p trong Firebase Config."); console.error(error); return false;
            }
        }

        // [FIX] H√†m ƒë·ªçc d·ªØ li·ªáu m·ªõi, an to√†n v√† ch√≠nh x√°c
        function processPastedColumns() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'ƒêang x·ª≠ l√Ω d·ªØ li·ªáu t·ª´ c√°c c·ªôt...';

            const words = document.getElementById('col-word').value.trim().split('\n');
            const types = document.getElementById('col-type').value.trim().split('\n');
            const pronunciations = document.getElementById('col-pronunciation').value.trim().split('\n');
            const meaningsVocab = document.getElementById('col-meaning-vocab').value.trim().split('\n');

            const structures = document.getElementById('col-structure').value.trim().split('\n');
            const meaningsStructure = document.getElementById('col-meaning-structure').value.trim().split('\n');

            if (words.length !== types.length || words.length !== pronunciations.length || words.length !== meaningsVocab.length) {
                throw new Error("S·ªë d√≤ng trong c√°c c·ªôt t·ª´ v·ª±ng kh√¥ng kh·ªõp nhau! Vui l√≤ng ki·ªÉm tra l·∫°i.");
            }
            if (structures.length !== meaningsStructure.length) {
                throw new Error("S·ªë d√≤ng trong c√°c c·ªôt c·∫•u tr√∫c kh√¥ng kh·ªõp nhau! Vui l√≤ng ki·ªÉm tra l·∫°i.");
            }

            const vocabData = words.map((word, index) => ({
                word: word.trim(),
                type: types[index].trim(),
                pronunciation: pronunciations[index].trim(),
                meaning: meaningsVocab[index].trim(),
            }));

            const structureData = structures.map((structure, index) => ({
                'c·∫•u tr√∫c / idiom / c·ª•m t·ª´': structure.trim(),
                '√Ω nghƒ©a': meaningsStructure[index].trim(),
            }));
            
            statusEl.innerHTML += `<br>‚úÖ ƒê√£ ƒë·ªçc th√†nh c√¥ng ${vocabData.length} t·ª´ v√† ${structureData.length} c·∫•u tr√∫c.`;
            return { vocabData, structureData };
        }


        function processDataSmart(vocabData, structureData) {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML += "<br>üß† B·∫Øt ƒë·∫ßu li√™n k·∫øt c·∫•u tr√∫c th√¥ng minh...";

            const vocabWords = vocabData.map(v => v.word);
            let structuresWithRootWord = [];

            structureData.forEach(struct => {
                const structureText = struct['c·∫•u tr√∫c / idiom / c·ª•m t·ª´'];
                if (!structureText) return;

                let found = false;
                for (const word of vocabWords) {
                    if (!word) continue;
                    const regex = new RegExp(`\\b${word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i');
                    if (regex.test(structureText)) {
                        structuresWithRootWord.push({ ...struct, word: word });
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    statusEl.innerHTML += `<br>‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y t·ª´ g·ªëc cho c·∫•u tr√∫c: '${structureText}'`;
                }
            });

            const structureGroups = structuresWithRootWord.reduce((acc, current) => {
                const key = current.word;
                if (!acc[key]) {
                    acc[key] = [];
                }
                acc[key].push(`${current['c·∫•u tr√∫c / idiom / c·ª•m t·ª´']}: ${current['√Ω nghƒ©a']}`);
                return acc;
            }, {});

            const finalVocabList = vocabData.map((vocabItem, index) => {
                const combinedStructure = structureGroups[vocabItem.word] ? structureGroups[vocabItem.word].join('; ') : '';
                return {
                    id: index + 1,
                    word: vocabItem.word || '',
                    type: vocabItem.type || '',
                    pronunciation: vocabItem.pronunciation || '',
                    meaning: vocabItem.meaning || '',
                    structure: combinedStructure
                };
            });
            
            statusEl.innerHTML += `<br>‚úÖ X·ª≠ l√Ω th√†nh c√¥ng ${finalVocabList.length} t·ª´ v·ª±ng.`;
            return finalVocabList;
        }

        document.getElementById('process-btn').addEventListener('click', async () => {
            if (!initializeFirebase()) return;

            const vocabSetId = document.getElementById('vocabSetId').value;
            const vocabSetTitle = document.getElementById('vocabSetTitle').value;
            const statusEl = document.getElementById('status');

            if (!vocabSetId || !vocabSetTitle) {
                alert("Vui l√≤ng ƒëi·ªÅn ID v√† Ti√™u ƒë·ªÅ c·ªßa b·ªô t·ª´ v·ª±ng.");
                return;
            }

            try {
                const { vocabData, structureData } = processPastedColumns();
                
                if (vocabData.length === 0 || vocabData[0].word === "") {
                    throw new Error("Kh√¥ng c√≥ d·ªØ li·ªáu t·ª´ v·ª±ng. Vui l√≤ng d√°n √≠t nh·∫•t m·ªôt c·ªôt 'Word'.");
                }

                const processedWords = processDataSmart(vocabData, structureData);
                
                const finalDataObject = {
                    title: vocabSetTitle,
                    words: processedWords
                };

                statusEl.innerHTML += `<br>ƒêang t·∫£i b·ªô t·ª´ v·ª±ng '${vocabSetId}' l√™n Firestore...`;
                
                await db.collection("vocab_sets").doc(vocabSetId).set(finalDataObject);

                statusEl.innerHTML += `<br>üéâ **TH√ÄNH C√îNG!** ƒê√£ t·∫£i b·ªô t·ª´ v·ª±ng l√™n Firestore.`;
                alert('T·∫£i l√™n th√†nh c√¥ng!');

            } catch (error) {
                statusEl.textContent = `L·ªói: ${error.message}`;
                console.error(error);
            }
        });
    </script>
</body>
</html>
